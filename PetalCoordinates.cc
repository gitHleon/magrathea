/*
 * PetalCoordinates.cpp
 *
 *  Created on: Jul 22, 2019
 *      Author: lacasta
 */
#include <iostream>
#include <fstream>
#include <sstream>
#include "PetalCoordinates.h"
//#include "string_utils.h"
#include <xlnt/xlnt.hpp>

static Point __nominal_upper_locator__(131.104, 968.526);
static Point __nominal__lower_locator__(0, 382.000);
static double __nominal_phi__    = (__nominal_upper_locator__ - __nominal__lower_locator__).phi();
static double __petal_rotation__ = -3.5e-3;

struct SensorData
{
        int iring;
        double Ri;
        double R;
        double Ro;
        double angle;
};

static SensorData __sensor_data__[] =
{
 {0, 384.050000, 438.614000, 488.873000, 0.000000},
 {1, 489.373000, 534.639000, 574.644000, 0.000000},
 {2, 575.144000, 609.405000, 637.659000, 0.000000},
 {3, 638.159000, 697.899000, 755.951000, 0.050397},
 {4, 756.451000, 812.471000, 866.512000, 0.050377},
 {5, 867.012000, 918.749000, 968.235000, 0.050381},
};

/*
 * Reads fiducials from the CSV generated by PetalSensors. These are
 * stored in EDMS
 *
 * Note that a 90 deg. rotation has been done compared to the files in EDMS
 * needed for a reference in which the petal is vertical.
 */
 /*
void read_csv_file(const char *fname, std::map<std::string, Point> &fiducials)
{
    std::ifstream ifile(fname);
    if (!ifile)
    {
        std::cout << "Could not open CSV file" << std::endl;
        return;
    }

    std::string line;
    MatrixTransform M;
   // M.rotate(M_PI_2);
    std::cout << "M90: " << M << std::endl;
    while ( std::getline(ifile, line) )
    {
        try
        {
            std::vector<std::string> tokens;
            stringtok(tokens, line, ",", true);

            Point P(std::stod(tokens[1])/1000.0,  std::stod(tokens[2])/1000.0);
            fiducials[tokens[4]] = M*P;
        }
        catch (std::invalid_argument &e) {}
    }

}
*/
void read_xlsx_file(const char *fname, std::map<std::string, Point> &fiducials)
{
    xlnt::workbook wb;
    try
    {
        wb.load(fname);
    }
    catch (xlnt::exception &e)
    {
        std::cout << "Excel file " << fname << " not found" << std::endl;
        return;
    }
    const xlnt::worksheet ws = wb.active_sheet();

    for (int irow=2; true; ++irow)
    {
        try
        {
            double X = ws.cell(2, irow).value<double>();
            double Y = ws.cell(3, irow).value<double>();
            std::string name = ws.cell(5, irow).value<std::string>();
            fiducials[name] = Point(X/1000.0, Y/1000.0);
        }
        catch ( std::exception &e)
        {
            break;
        }
    }
}


PetalCoordinates::PetalCoordinates()
{

}

PetalCoordinates::PetalCoordinates(const Point &upper_locator, const Point &lower_locator)
    : top(upper_locator), bottom(lower_locator)
{
    set_reference(upper_locator, lower_locator);
}

void PetalCoordinates::clear_maps()
{
    sensor_transform.clear();
    sensor_positions.clear();
    sensor_positions_gantry.clear();
    fiducials.clear();
    fiducials_gantry.clear();
}

void PetalCoordinates::set_reference(const Point &upper_locator, const Point &lower_locator)
{
    // Save coordinates
    top = upper_locator;
    bottom = lower_locator;

    /**
     * clear the existing coordinate maps
     */
    clear_maps();

    /*
     * upper_locator and lower_locator, together with the Y axis
     * define the petal coordinate system
     *
     * First set the origin in the lower locator
     */
    translate(-lower_locator);

    /*
     * Transform upper_locator and compute the actual phi angle
     */
    rotate(__nominal_phi__ - transform(upper_locator).phi());
    _inv = inverse();

    /*
     * read the fiducial file
     * TODO: find a way (QSettings?) to store the path to this file
     */
    std::map<std::string, Point> _fiducials;
    const char *table = std::getenv("FIDUCIAL_TABLE");
    if (!table)
    {
        //read_csv_file("EC-sensor-fiducials.csv", _fiducials);
        read_xlsx_file("EC-sensor-fiducials.xlsx", _fiducials);
    }
    else
        read_xlsx_file(table, _fiducials);

    /**
     *  Now get the location of the sensors in the reference Petal and store the transform matrix.
     *
     *
     */
    for (int iring=0, cntr=0; iring<6; ++iring)
    {
        int nsensor = 1;
        if (iring>2)
            nsensor = 2;

        for (int isensor=0; isensor < nsensor; ++isensor)
        {
            double angle = __sensor_data__[iring].angle;
            if (isensor==0)
                angle = -angle;

            angle += __petal_rotation__;

            Point Psensor(0,0);
            MatrixTransform M;
            M.translate(0.0, __sensor_data__[iring].R);
            M.rotate(angle);
            M.translate(-__nominal__lower_locator__);
            sensor_transform.push_back(M);

            Point pos = M.transform(Point(0,0));
            sensor_positions.push_back(pos);
            sensor_positions_gantry.push_back(_inv.transform(pos));
            cntr++;

            // Fiducials
            // this could be more efficient, but after all it is only executed once....
            std::ostringstream osensor;
            osensor << "R" << iring;
            std::string sensor_name = osensor.str();
            for (auto &F: _fiducials)
            {
                if (F.first.find(sensor_name) == 0)
                {
                    std::ostringstream oname;
                    oname << F.first << "_" << isensor;
                    std::string name = oname.str();
                    Point Q = M.transform(F.second);
                    fiducials[name] = Q;
                    fiducials_gantry[name] = _inv.transform(Q);
                }
            }
        }
    }
}

void PetalCoordinates::cpy(const PetalCoordinates &PC)
{
    // copy the Matrix transform
    *dynamic_cast<MatrixTransform *>(this) = *dynamic_cast<const MatrixTransform *>(&PC);

    // now the local members
}

PetalCoordinates::~PetalCoordinates()
{
    // TODO Auto-generated destructor stub
}

PetalCoordinates::PetalCoordinates(const PetalCoordinates &other)
{
    cpy(other);
    // TODO Auto-generated constructor stub

}

PetalCoordinates& PetalCoordinates::operator=(const PetalCoordinates &other)
{
    // TODO Auto-generated method stub
    if (this != &other)
        cpy(other);

    return *this;
}

Point PetalCoordinates::get_sensor_pos_in_petal(Sensor ss) const
{
    return sensor_positions[ss];
}
Point PetalCoordinates::get_sensor_pos_in_gantry(Sensor ss) const
{
    return sensor_positions_gantry[ss];
}

std::string build_fiducial_name(const std::string &type, int iring, int side, int cntr)
{
    std::ostringstream oname;
    oname << "R" << iring << "_" << type << "_" << cntr << "_" << side;
    return oname.str();
}

Point PetalCoordinates::get_fiducial_in_petal(const std::string &type, int iring, int side, int cntr) const
throw(PetalCoordException)
{
    std::string name = build_fiducial_name(type, iring, side, cntr);
    auto it = fiducials.find(name);
    if (it == fiducials.end())
        throw PetalCoordException("Fiducial not found");

    return it->second;
}

Point PetalCoordinates::get_fiducial_in_gantry(const std::string &type, int iring, int side, int cntr) const
throw(PetalCoordException)
{
    std::string name = build_fiducial_name(type, iring, side, cntr);
    auto it = fiducials_gantry.find(name);
    if (it == fiducials.end())
        throw PetalCoordException("Fiducial not found");

    return it->second;
}

Point PetalCoordinates::gantry_to_petal(const Point &P) const
{
    return transform(P);
}

Point PetalCoordinates::petal_to_gantry(const Point &P) const
{
    return _inv.transform(P);
}
